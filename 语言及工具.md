##语言

###基本知识

**编译程序是一种 **

```
翻译程序
目标程序
汇编程序
解释程序
```

翻译程序

**以下哪个选项一定可以将flag的第二个bit置0 **

```
flag&=~2
flag|=2
flag^=2
flag>>=2
```

负数在计算机中的存储方式

以补码的形式存储：

正数的补码就是 其本身

负数的补码是取绝对值后，再取反后，再加1

A选项 先取反 再进行与运算。～2的结果为1111 1101 再与flag，与 flag的第二位一定为0. B选项 flag的第二位为1. C选项 ^ 相同为0 不同为1 flag的第二位可能为0可能为1. D选项 右移运算 不能确定第四位到底是1或者是0. 答案为A. 

### 进程和线程

https://www.zhihu.com/question/25532384

**进程和线程都是一个时间段的描述，是CPU工作时间段的描述。**

在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：**先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。**

- **进程就是包换上下文切换的程序执行时间总和** = **CPU加载上下文+CPU执行+CPU保存上下文**

**线程是什么呢？**进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这

里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。

进程，在一定的环境下，把静态的程序代码运行起来，通过使用不同的资源，来完成一定的任务。比如说，进程的环境包括环境变量，进程所掌控的资源，有中央处理器，有内存，打开的文件，映射的网络端口等等。

一个系统中，有很多进程，它们都会使用内存。为了确保内存不被别人使用，每个进程所能访问的内存都是圈好的。

线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。这里想强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。

###语言执行

**字符串"//＾▽＾//\n"的长度是 **

9，'\n'算一个字符

**执行以下代码**

```
#define SUM(x,y) x+y
int a=3;
int b=2;
a+=aSUM(a,b)b;
```

a的值为：16

**对于以下代码**，

char* p=new char[100];

正确的是

```
p和new出来的内存都在栈上
p和new出来的内存都在堆上
p在堆上，new出来的在栈上
p在栈上，new出来的在堆上
```

D

**内存空间被分成不同区域,其中用函数**

> void* malloc(unsigned int size);

申请的内存在()

```
程序区
静态存储区
动态存储区
ROM区
```

stack由系统自动分配，heap需要程序员自己申请，C中用函数malloc、calloc 分配空间，用free释放，C++用new分配，用delete释放。

当然热爱java的童鞋肯定更关心java的内存空间划分（虽然强大的java让程序猿在编程时不需要考虑太多内存方面的细节）

java 对内存空间的划分五部分； 
栈、堆、方法区、本地方法区、寄存器。 
1、栈内存：存储都是局部变量。只要是在方法中定义的变量都是局部变量。 
一旦变量的生命周期结束该变量就被释放。 
2、堆内存都是实体（对象）（new 关键词创建的） 
每一个实体都有一个首地址值。 
堆内存的变量都有默认的初始化值。不同类型不一样， 
int——0，double——0.0 boolean——false char——’\u0000’ 
当实体不在使用时，就会被垃圾回收机制处理。

**编译和执行如下c语言代码,系统将会输出什么? **

```
#include<stdio.h>
int main()
{
    char c='0';
    printf("%d %d",sizeof(c),sizeof(char));
    return 0;
}
```

**sizeof(c)永远是1**，因为sizeof是计算其类型的大小，类型为char，结果必然是1；

**sizeof('0')的结果取决于‘0’的类型**，c++中‘0’为字符常量，类型为char，结果为1，

如果是**sizeof('02')**,C++中‘02’为整型字符常量，为int类型，结果为4.

所以结果是输出1,1

C语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 4 

C++语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 1 

字符型变量是1字节这个没错，奇怪就奇怪在C语言认为'a'是4字节，而C++语言认为'a'是1字节。 

原因如下:  

  C99标准的规定，'a'叫做整型字符常量(integer    character constant)，被看成是int型，所以在32位机器上占4字节。

  ISO C++标准规定，'a'叫做字符字面量(character literal)，被看成是char型，所以占1字节

**用变量a给出下面的定义:一个有10个指针的数组,该指针指向一个函数,该函数有一个整形参数并返回一个整型数 **

```
int *a[10];
int (*a)[10];
int (*a)(int);
int (*a[10])(int);
```

```
int *a[10];   //指向int类型的指针数组a[10]
int (*a)[10]; //指向有10个int类型数组的指针a
int (*a)(int);//函数指针，指向有一个参数并且返回类型 均为int的函数
int (*a[10])(int); //函数指针的数组，指向有一个参数并且返回类型均为int的函数的数组
表达式可以遵循这样的规则:从右向左，由近及远，括号优先；比如 
从a符号开始。其右边是[10]，说明a是个数组，其中存了十个元素。 
再看a的左边是一个*。说明数组中存的是指针。 
现在在看(*a[10])的右边是(int);说明所存的指针是指向有一个int形参的函数 
现在看(*a[10])的左边是个int ，说明指向的函数的返回值为int 类型
```

**执行"int x=1;int y=~x;"语句后,y的值为？ **

-2，假设int占2个字节，那么1的二进制表示是 0000 0001 ，~表示按位取反，则 0000 0001变为 1111 1110，在计算机中整数用补码形式表示，正数的补码是它本身，负数的补码是原数值除符号位按位取反再加一，由补码求原数值也是按位取反再加一，那么 1111 1110 除符号位按位取反再加一变成 1000 0010，即 -2。 

```
int main(){
  int a;float b,c;
  scanf("%2d%3f%4f",&a,&b,&c);
  printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
```

**若运行时从键盘上输入9876543210l,则上面程序在gcc编译器下的输出结果是 **

```
a=98,b=765,c=4321.000000
a=98,b=0,c=0.000000
a=98,b=765.000000,c=4321.000000
a=98,b=765.0,c=4321.0
```

B，

scanf("%2d%3f%4f",&a,&b,&c)后

如果直接cout<<a<<" "<<b<<" "<<c<<endl; 输出 98 765 4321

如果是 printf("\na=%d,b=%f,c=%f\n",a,b,c);输出a=98,b=765.000000,c=4321.000000

如果是 printf("\na=%d,b=%d,c=%f\n",a,b,c);输出a=98,b=0,c=0.000000

如果单独printf("c=%f\n",a,b,c);输出c=4321.000000

题目中由于b是float，却以%d输出，直接为0，影响了printf的正常输出

printf函数执行的时候，会先把这三个数字压入栈里，然后再执行打印。压入栈的时候按照数据本身的长度来，首先把c和b压入，并且每一个都是8个字节（printf自动转化为double）。然后再压入a是4个字节。然后再执行打印。打印的时候按照用户指定的格式来出栈。首先打印a，a打印正常。然后又打印4个字节长度的b，在栈里面由于b长度是八个字节，并且b目前是64位的表示方式，数据的后面全是0.（float 变double），电脑是小端存储方式，0存储在距离a近的地方。打印b的时候，打印的4个字节都是0.然后再打印c，c用正常的方式打印，会一下子读取8个字节，正好，读出来的八个字节前面四个字节全是0，自己可以算一下，实在太小了，因此为0.

栈底                                          栈顶

高字节。。。。。。。。。。。低字节

4321     0000      765     0000         98

4字节   4字节    4字节    4字节      4字节

​             打印c                 打印b      打印a

附：浮点数（单精度的float和双精度的double）在内存中以二进制的科学计数法表示，表达式为N = 2^E * F；其中E为阶码（采用移位存储），F为尾数。

float和double都由符号位、阶码、尾数三部分组成，float存储时使用4个字节，double存储时使用8个字节。各部分占用位宽如下所示：

​             符号位     阶码      尾数     长度

float              1           8         23      32

double          1         11        52       64

**下列代码的输出结果是_____ **

```
boolean b=true?false:true==true?false:true;
System.out.println(b);
```

false

==  优先级高于 三目运算符，先判断   true == true，此时返回为  true,

这时表达式为   boolean b = true?false:true?false:true

此时三目运算符从右向左执行,true?false:true，返回false

这时表达式为  boolean b = true?false:false;

结果为：boolean b = false ;

**选项代码中能正确操作数组元素的是()**

```
int main(){
  int a[N][N]={{0,0},{0,0}};
  for(int i=0;i<N;i++){
     for(int j=0;j<N;j++){
       //访问二维数组a的值
       //选项代码
      }
    }
}
```

```
*(*(a+i)+j)=1
*(a[i]+j)=1
**(a+i)[j]=1
*((a+i)+j)=1
```

数组名当被直接使用时，是一个指向数组首地址的指针。如果数组是多维数组，那么数组名是指向第一行数组的首地址，而不是第一行第一列单个元素的地址，所以\*(a+i)与a[i]是一个意思，当直接用a[i]时代表的是该一维数组的首地址，所以*(a[i]+j)是与a\[i][j]等效，所以AB选项正确

**在linux+gcc下,关于以下代码,正确的是()**

```
std::string& test_str()
{
   std::string str="test";
   return str;
}
int main()
{
   std::string& str_ref=test_str();
   std::cout<<str_ref<<std::endl;
   return 0;
}
```

```
编译警告
返回局部变量的引用,运行时出现未知错误
正常编译且运行
把代码里的&都去掉之后,程序可以正常运行
```

ABD，引用返回的是局部变量本身，而不是复制一份再返回，所以结果难以预料；其次返回局部自动变量是可以的，只要不是地址或引用就可以，否则需要将变量声明成static类型。

1. 局部变量用作返回值时，会生成一个**局部变量的拷贝用作返回值**，之后局部变量会被系统回收；
2. 函数不能返回局部变量的地址，因为如果返回局部变量的地址，系统回收后，指针、引用指向的内容就无意义了。

### Python

a=[1,2,3]

b=[1,2,3]

id(a[1])==id(b[1])

True

### C/C++

**关于虚函数的描述正确的是()**

```
派生类的虚函数与基类的虚函数具有不同的参数个数和类型
内联函数不能是虚函数
派生类必须重新定义基类的虚函数
虚函数可以是一个static型的函数
```

B，虚函数是为了实现动态绑定，不能声明为虚函数的有：

1、静态成员函数； 2、类外的普通函数； 3、构造函数； 4、友元函数

此外，还有一些函数可以声明为虚函数，但是没有意义，但编译器不会报错，如：

1、赋值运算符的重载成员函数： 因为复制操作符的重载函数往往要求形参与类本身的类型一致才能实现函数功能，故形参类型往往是基类的类型，因此即使声明为虚函数，也把虚函数当普通基类普通函数使用。

2、内联函数：内联函数目的是在代码中直接展开（编译期），而虚函数是为了继承后能动态绑定执行自己的动作（动态绑定），因此本质是矛盾的，因此即使内联函数声明为虚函数，编译器遇到这种情况是不会进行inline展开的，而是当作普通函数来处理。因此声明了虚函数不能实现内敛的，即内敛函数可以声明为虚函数，但是毫无了内联的意义

**关于函数输入参数的正确描述都有哪些?() **

```
始终用const限制所有指向只读输入参数的指针和引用
值传递只用于原始类型(int,float...)的输入参数
优先按const的引用取得其他用户定义类型的输入
如果函数需要修改其参数副本,则可以考虑通过值传递代替通过引用传递
```

ACD，

**对以下数据结构中data的处理方式描述正确的是()**

```
struct Node
{
   int size;
   char data[0];
};
```

```
data将会被编译成一个char *类型指针
全部描述都不正确
编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问
编译器会默认将数组data的长度设置为1
```

C

###Linux

**在给定文件中查找与设定条件相符字符串的命令 **

```
gzip
grep
ls
find
```

grep

**Linux文件权限一共10位长度，分成四段，第三段表示的内容是 **

```
文件所有者的权限
文件所有者所在组的权限
其他用户的权限
文件类型
```

B

##工具

**JUnit主要用来完成什么 **

单元测试，JUnit是一个Java语言的单元测试框架，有程序员自测，就是所谓的白盒测试，主要四个方向 1、用于测试期望结果的断言（Assertion）2、用于共享共同测试数据的测试工具  3、用于方便的组织和运行测试的测试套件  4、图形和文本的测试运行器 

**以下开源软件中经常被用作消息队列的是哪个 **

```
Kafka
MongoDB
Hadoop
Spark
```

A，Redis和kafka都是常见的开源队列。 