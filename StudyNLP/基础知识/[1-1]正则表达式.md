正则表达式(regular expression, 简称RE)描述了一种字符串匹配的模式(pattern)，可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

通过使用正则表达式，可以： 

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。例如Linux中的`grep`命令使用正则表达式查找文件里符合表达式条件的内容。

## 基本的正则表达式

正则表达式语法由字符和操作符构成， 字符例如字母和数字表示他们自身。很多标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。

最简单的正则表达式是一串字符，例如`woodchuck`表达式可以匹配字符串"woodchuck"，`!`可以匹配感叹号"!"。正则表达式是**大小写敏感**的，所以`woodchuck`无法匹配到"Woodchuck"，可以使用`[wW]oodchuck`匹配"Woodchuck"和"woodchuck"。其中`[...]`用来表示单个字符的取值范围。

下面结合例子来熟悉一下正则表达式，用下划线来表示正则匹配到的字符串。

| 正则表达式              | 匹配                         | 举例                                     | 涉及知识点                            |
| ----------------------- | ---------------------------- | ---------------------------------------- | ------------------------------------- |
| `[wW]oodchuck`          | Woodchuck或woodchuck         | <u>Woodchuck</u>                         | 大小写敏感，`[]`表示字符取值范围      |
| `[abc]`                 | 'a', 'b'或'c'                | In uomini, in sold<u>a</u>ti             | `[]`表示字符取值范围                  |
| `[0-5]`                 | 0-5之间的数字                | plenty of 7 of <u>5</u>                  | `-`简单指定范围                       |
| `[A-Z]`                 | 一个大写字母                 | <u>M</u>r.<u>L</u>i                      | `-`简单指定范围                       |
| `[0-9]`                 | 单个数字，等价于[1234567890] | Chapter <u>1</u>                         | `-`简单指定范围                       |
| `[^A-Z]`                | 非大写字母                   | M<u>r</u>                                | `[^...]`表示非指定字符之外的字符。    |
| `[e^]`                  | 匹配'e'或者'^'               | look up <u>^</u>                         | `^`不在`[]`中第一个字符时不表示“非”   |
| `a^b`                   | 匹配"a^b"                    | look <u>a^b</u>                          | 同上                                  |
| `^the`                  | 匹配字符串的the              | <u>the</u> dog or the cat                | `^`在模式第一个字符时表示字符串的开头 |
| `the dog\.$`            | 匹配以the dog.结尾的字符串   | the cat or <u>the dog.</u>               | `$`表示字符串的结尾                   |
| `woodchucks?`           | 匹配woodchuck或woodchucks    | <u>woodchuck</u>                         | `?`表示前一个字符出现0次或1次         |
| `colou?r`               | color或colour                | <u>colour</u>                            | 同上                                  |
| `aa*`                   | a或aa或aaa...                | <u>aaaa</u>                              | `*`表示前一个字符出现0次或多次        |
| `[ab]*`                 | 0个或多个连续的a或b          | <u>aaa</u>, <u>abab</u>, <u>bbb</u>      | 同上                                  |
| `[0-9][0-9]*`或`[0-9]+` | 1个或多个连续的数字          | $<u>123</u>                              | `+`表示前一个字符出现1次或多次        |
| `beg.n`                 | beg+任意字符+n               | <u>begin</u>, <u>beg'n</u>, <u>begun</u> | `.`表示任意单个字符(除了换行符)       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |

P14

## 匹配单个字符

1.匹配纯文本，比如Ben，think等。

- 可能有多个匹配结果，比如Python中的re.find是只返回第一个匹配结果，re.findall是返回所有匹配结果。
- 字母是大小写敏感的，B只能匹配B，不能匹配b。Python库中的参数re.I可以设置是否忽略大小写。



2.匹配任意单个字符用`.`

3.匹配特殊字符。一些字符在正则表达式里有特殊的含义，比如`.`表示任意单个字符，如果想匹配`.`这个字符，就要用转移字符`\`，即`\.`就可以匹配`.`这个字符。

## 匹配一组字符

1.匹配多个字符中的某一个用`[]`，比如`[abc]`表示匹配a或b或c

2.利用字符集合区间，比如`[0-9]`表示匹配0-9里的任意数字, 其它的字符集合区间还有`[A-Z]`, `[a-z]`, `[a-f]`等

3.取非匹配`^`，也就是说，除了那个字符集合里的字符，其它字符都可以匹配。比如`[^0-9]`匹配任意不是数字的字符。

re.search是Python的正则表达式操作函数，表示“进行正则表达式匹配”，charStr是需要判断的字符串，"[0123456789]"则是以字符串形式给出的正则表达式。

```python
# 能匹配则返回RegexObject，否则返回None
re.search("[0-9]", charStr)
```

在很多语言中还可以用转义序列`\xhex`来表示一个字符，其中`\x`是固定前缀，表示转义序列的开头，`num`是字符对应的码值（Code Point），是一个两位的十六进制数值。比如字符A的码值是41（十进制则为65），所以也可以用`\x41`表示。

```python
# 字符组
re.search("^[\x00-\x7F]$", charStr)
```

`\s\S`, `\w\W`, `\d\D`可以匹配任意字符，大小写是互补的。

## 使用元字符

1.元字符是一些在正则表达式里有有特殊含义的字符，这些字符无法用来代表它本身。只有在元字符前面加上反斜杠`\`才能用来表示它本身。

要匹配`\`本身，也要在前面加上`\`，得到`\\`。

2.匹配空白字符

| 元字符 | 说明                              |
| ------ | --------------------------------- |
| `[\b]` | 回退(并删除)一个字符(Backspace键) |
| `\f`   | 换页符                            |
| `\n`   | 换行符                            |
| `\r`   | 回车符                            |
| `\t`   | 制表符(Tab键)                     |
| `\v`   | 垂直制表符                        |

比如`\r\n`匹配一个“回车+换行”组合，有许多操作系统（比如Windows）都把这个组合用作文本行的结束标签。Unix和Linux系统只使用一个换行符来结束一个文本行。

3.匹配特定的字符类别

| 元字符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `\d`   | 任何一个数字字符(等价于`[0-9]`)                              |
| `\D`   | 任何一个非数字字符(等价于`[^0-9]`)                           |
| `\w`   | 任何一个字符数字字符(大小写均可)或下划线字符(等价于`[a-zA-Z0-9_]`) |
| `\W`   | 任何一个非字母数字或下划线字符(等价于`[^a-zA-Z0-9_]`)        |
| `\s`   | 任何一个空白字符(等价于`[\f\n\r\t\v]`)                       |
| `\S`   | 任何一个非空白字符(等价于`[^\f\n\r\t\v]`)                    |

十六进制，比如`\x0A`对应于ASCII字符10(换行符)，其效果等价于`\n`

八进制，比如`\011`对应于ASCII字符9(制表符)，其效果等价于`\t`。

4.使用POSIX字符类

POSIX字符类是许多(但不是所有)正则表达式实现都支持的一种简写形式。

| 字符类       | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| `[:alnum:]`  | 任何一个字母或数字(等价于`[a-zA-Z0-9]`)              |
| `[:alpha:]`  | 任何一个字母(等价于`[a-zA-Z]`)                       |
| `[:blank:]`  | 空格或制表符(等价于`[\t ]`)                          |
| `[:cntrl:]`  | ASCII控制字符(ASCII 0到31，再加上ASCII 127)          |
| `[:digit:]`  | 任何一个数字(等价于`[0-9]`)                          |
| `[:graph:]`  | 和`[:print:]`一样，但不包括空格                      |
| `[:lower:]`  | 任何一个小写字母(等价于`[a-z]`)                      |
| `[:print:]`  | 任何一个可打印字符                                   |
| `[:punct:]`  | 既不属于`[:alnum:]`也不属于`[:cntrl:]`的任何一个字符 |
| `[:space:]`  | 任何一个空白字符，包括空格(等价于`[^\f\n\r\t\v ]`)   |
| `[:upper:]`  | 任何一个大写字母(等价于`[A-Z]`)                      |
| `[:xdigit:]` | 任何一个十六进制数字(等价于`[a-fA-F0-9]`)            |

注意`[]`是POSIX字符类本身的组成部分

## 重复匹配

匹配一个或多个字符：给字符(或字符集合)加上`+`字符作为后缀

匹配零个或多个字符：给字符(或字符集合)加上`*`字符作为后缀

匹配零个或一个字符：给字符(或字符集合)加上`?`字符作为后缀

为重复匹配次数设定一个精确的值，`{数字}`

为重复匹配次数设定一个区间，`{最小值，最大值}`，注意是闭区间

匹配“至少重复多少次”，`{最小值,}`

防止过度匹配：`*`和`+`都是“贪婪型”元字符，它们在进行匹配时会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配为止。

这些元字符的“懒惰型”版本是给贪婪型元字符加上一个`?`后缀。

常用的贪婪型元字符有`*`, `+`, `{n,}`，他们的懒惰型版本分别是`*?`, `+?`, `{n,}?`

## 位置匹配

`\b`用来匹配一个单词的开始或结尾（单词边界），它匹配的是一个这样的位置，这个位置位于一个能够用来构成单词的字符（字母、数字和下划线，也就是与`\w`相匹配的字符）和一个不能用来构成单词的字符（也就是与`\W`相匹配的字符）之间。它可以匹配句子的第一个单词。

`\B`匹配非单词边界，即匹配字母数字下划线之间，或者非字母数字下划线之间（取决于想匹配的字符）

比如`\B-\B`去匹配Please enter the nine-digit id as it appears on your color - coded pass-key这句话，nine-digit和pass-key中的连字符不能与之匹配，但color - coded中的连字符可以与之匹配。

用`\Bi\B`去匹配上述句子，nine-digit里的3个`i`都能匹配，剩下的不能匹配。

注意除了字母数字下划线，其它的字符都视为单词边界

字符串边界：匹配字符串开头用`^`，结尾用`$`

分行匹配模式`(?m)`将使得正则表达式引擎把行分隔符当作一个字符串分隔符来对待。这个模式必须出现在整个模式的最前面。比如`(?m)^\w+`可以提取字符串中每行的第一个单词。`(?m)\w+$`可以提取字符串中每行的最后一个单词。

不同平台的行终止符：

- Unix/Linux：`\n`
- Windows：`\r\n`
- Mac OS：`\n`

如果我们不想定位到字符串内部的行起始位置，只关心整个字符串的起始位置，则可以使用`\A`，绝大多数工具的正则表达式都支持。`(?m)\A\w+`匹配整段文本的第一个单词。

`\Z`和`\z`不受多行模式的影响，在任何情况下都匹配整个字符串的结束位置。`\Z`等价于默认模式(非多行模式)下的`$`，如果字符串的末尾有行终止符，则它匹配换行符之前的位置；`\z`则不管行终止符，只匹配整个字符串的结束位置。

注意Python不支持`\z`，Python的`\Z`等价于其他语言中的`\z`.

```python
# 数据验证
# $匹配结尾行终止符之前的位置，会忽略末尾的行终止符
re.search(r"^\d{6}$", "123456\n") != None   # True
# ^和$一般成对出现，这里用\A更符合习惯
re.search(r"\A\d{6}\Z", "123456\n") != None   # False
```

`^`和`$`进行正则表达式替换时并不会被替换。常见的应用是将纯文本转换为HTML，比如将纯文本的电子文档转换成ePub格式。最简单的思路是使用多行模式将`^`替换为`<p>`，将`$`替换为`</p>`。

`^`和`$`的替换

```python
plainText = "line1\nline2\nline3"
re.sub("(?m)$", "</p>", re.sub("(?m)^", "<p>", plainText))
# <p>line1</p>\n<p>line2</p>\n<p>line3</p>
```

去除行首的空白字符

```python
withSpaces = "   begin\n between\t\n\nend  "
beginSpaceRegex = "(?m)^\s+"
trimmedLeadingSpace = re.sub(beginSpaceRegex, "", withSpaces)
trimmedLeadingSpace
# begin\nbetween\t\nend  (末尾的空白字符没有删掉)
endSpaceRegex = "(?m)\s+$"
trimmedEndingSpace = re.sub(endSpaceRegex, "", trimmedLeadingSpace)
trimmedEndingSpace
# begin\nbetween\nend(末尾的空白字符已经删掉)

# 能不能一步到位呢？
withSpaces = "   begin\n between\t\n\nend  "
spaceRegex = r"(?m)(^\s+|\s+$)"
spaceTrimmed = re.sub(spaceRegex, "", withSpaces)
spaceTrimmed
# begin\nbetweenend(第二行和第四行合并了)
```



## 子表达式(分组)

子表达式用()括起来，子表达式是一个独立元素。比如`(19|20)\d{2}`匹配19或20开头的4位数字(这种形式称为多选结构)，多选结构可以没有括号，比如`19|20`，但还是推荐写括号。

多选结构的排列是有讲究的，比如`(jeff|jeffrey)`用来匹配jeffrey，结果会是什么呢？这个问题没有标准答案，Java, .NET, Python, Ruby, JavaScript, PHP中都会优先选择最左侧的分支。在平时使用时应当尽量避免多选分支中存在重复匹配，因为这样会大大增加回溯的计算量。也就是说，应当避免这样的情况：针对多选结构`(option1|option2)`，某段文本既可以由option1匹配，也可以由option2匹配。

例子：匹配合法的IP地址，地址的各位数字必须符合的规则是

- 任何一个1位或2位数字
- 任何一个以1开头的3位数字
- 任何一个以2开头、第2位数字在0~4之间的3位数字
- 任何一个以25开头、第3位数字在0~5之间的3位数字

正则表达式：`(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))`

- 匹配月：`(0?[1-9]|1[012])`
- 匹配日：`(0?[1-9]|[12]\d|3[01])`
- 匹配小时：`(0?[1-9]|[01]\d|2[0-4])`
- 匹配分钟：`(0?[1-9]|[0-5]\d|60)`
- 匹配手机号码：`(0|\+86)?(13[0-9]|15[0-356]|18[025-9])\d{8}`

### 引用分组(捕获分组)

```python
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(1)
# 2010
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(2)
# 12
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(3)
# 22
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(0)
# 2010-12-22
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group()
# 2010-12-22
```

无论括号如何嵌套，分组的编号都是根据开括号出现顺序来计数的。

容易犯错的：

```python
re.search("(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(1)
# 2010
re.search("(\d){4}-(\d{2})-(\d{2})", "2010-12-22").group(1)
# 0
# 编号为1的分组匹配的文本的值依次是2、0、1、0，最后的结果是0
```



在替换中使用分组

```python
re.sub("(\d{4})-(\d{2})-(\d{2})", r"\2/\3/\1", "2010-12-22")
# 12/22/2010
re.sub("(\d{4})-(\d{2})-(\d{2})", r"\1年\2年\3日", "2010-12-22")
# 2010年12月22日
```

因为`\1`,`\2`不是字符串中的合法转义序列，所以必须指定为原生字符串，在字符串前面加一个"r"。

如果想引用整个表达式匹配的文本，不能使用`\0`，因为`\0`开头的转义序列通常表示用八进制形式表示的字符，`\0`本身表示ASCII字符编码为0的字符。如果一定要引用整个表达式匹配的文本，则可以稍加变通，给整个表达式加上一对括号，之后用`\1`来引用。

```python
re.sub("((\d{4})-(\d{2})-(\d{2}))", "[\\1]", "2010-12-22")
# [2010-12-22]
re.sub("((\d{4})-(\d{2})-(\d{2}))", r"[\1]", "2010-12-22")
# [2010-12-22]
```



## 回溯引用：前后一致匹配(反向引用)

回溯引用允许正则表达式模式引用前面的匹配结果

比如在一段文本里找出所有连续2次重复出现的单词，`[ ]+(\w+)[ ]+\1`，`\1`就是一个回溯引用，引用的是前面划分出来的子表达式`(w+)`

`\1`代表模式里的第1个子表达式，`\2`代表第2个子表达式...

匹配HTML的任何一级标题的开始标签和与之配对的结束标签（忽略任何不配对的标签组合），`<[hH]([1-6])>.*?</[hH]\1>`

回溯引用在替换操作中的应用

- 把电话号码313-555-1234重新排版为(313) 555-1234

- 正则表达式`(\d{3})(-)(\d{3})(-)(\d{4})`
- 替换`($1) $3-$5`

大小写转换（只有部分正则表达式的实现支持）

| 元字符 | 说明                             |
| ------ | -------------------------------- |
| `\E`   | 结束\L或\U转换                   |
| `\l`   | 把下一个字符转换为小写           |
| `\L`   | 把\L到\E之间的字符全部转换为小写 |
| `\u`   | 把下一个字符转换为大写           |
| `\U`   | 把\U到\E之间的字符全部转换为大写 |

比如把一级标题的标题文字转换为大写

正则表达式：`(<[hH]1>)(.*?)(</[hH]1>)`

替换：`$1\U$2\E$3`

用反向引用匹配重复字母

```python
re.search(r"^([a-z])\1$", "aa") != None   # True
re.search(r"^([a-z])\1$", "ac") != None   # False
```

解析HTML代码时匹配tag：`<([^>]+)>[\s\S]*?</\1>`

如果tag后面有属性，例如`<span class="class1">text</span>`。就要修改表达式为`<([a-zA-Z0-9]+)(\s[^>]+)?>[\s\S]*?</\1>`

可能具有二义性的反向引用：

`\10`是表示第10个捕获分组还是第1个捕获分组之后跟着一个字符0呢？

在Python中，`\10`会被解释成第10个捕获分组匹配的文本，下面的程序会报错：

```python
print(re.sub(r"(\d)", r"\10", "123"))
```

如果希望效果是第1个捕获分组之后跟着一个字符0，那就要写成`\g<1>0`

```python
re.sub(r"(\d)", r"\g<1>0", "123")
# 102030
```



### 命名分组

标识分组为容易记忆和辨别的名字，而不是数字编号。

Python中用`(?P<name>regex)`来分组。用法举例：

```python
namedRegex = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"
result = re.search(namedRegex, "2010-12-22")
print(result.group("year"))  # 2010，等价于result.group(1)
print(result.group("month"))  # 12，等价于result.group(2)
print(result.group("day"))  # 22，等价于result.group(3)
```

即便使用了命名分组，每个命名分组同时也具有数字编号。

Python中，如果使用了命名分组，在表达式反向引用时，必须使用`(?P=name)`的记法，而要进行正则表达式替换，则要写作`\g<name>`

```python
re.search(r"^(?P<char>[a-z])(?P=char)$", "aa") != None  #True
re.sub("(?P<digit>\d)", r"\g<digit>0", "123")  # 102030
```

### 非捕获分组

`(?:...)`只能限定量词的作用范围，不捕获任何文本。在引用分组时，分组的编号同样会按开括号出现的顺序从左到右递增，只是必须以捕获分组为准，会略过非捕获分组。

```python
re.search(r"(\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(2)
# 12
re.search(r"(?:\d{4})-(\d{2})-(\d{2})", "2010-12-22").group(1)
# 12
```

有些结构并不真正匹配文本，而只负责判断在某个位置左右侧的文本是否符合要求，这种结构被称为断言(assertion)。常见的断言有三类：单词边界、行起始/结束位置、环视。

断言不匹配任何字符，只匹配位置；而反向引用只引用之前的捕获分组匹配的文本，之前捕获分组中锚点表示的位置信息，在反向引用时并不会保留下来。

如果表达式是`(\bcat\b)\s+\1`，`\1`所匹配的，就不只有单独出现的cat，还包括单词内部的cat(比如cate中的cat)，如果要验证单词cat是否在字符串中出现了两次，正确的做法是在反向引用两端加上单词边界，变成`(\bcat\b).*?\b\1\b`

```python
re.search(r"(\bcat\b).*?\1", "cat cate") != None  # True
re.search(r"(\bcat\b)\s+\b\1\b", "cat cate") != None  # False
re.search(r"(\bcat\b)\s+\b\1\b", "cat cat") != None  # True
```



## 前后查找/环视(非捕获分组)

环视类似单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符。

向前查找指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个以`?=`开头的子表达式，需要匹配的文本跟在后面。

模式`.+(:)`查找到并且匹配结果包含`:`，模式`.+(?=:)`查找到但匹配结果不包含`:`。

向前查找是查找出现在匹配文本之后的字符，但不消费那个字符。向后查找是查找出现在被匹配文本之前的字符，但不消费它。向后查找操作符是`?<=`

比如匹配价格。`\$[0-9.]+`匹配`$`开头的价格，会返回`$`。`(?<=\$)[0-9.]+`不会返回`$`。

向前查找模式的长度是可变的，它们可以包含`.`和`+`之类的元字符，所以非常灵活。

向后查找模式只能是固定长度。

向前查找和向后查找可以结合起来。

对前后查找取非，即查找不与给定模式相匹配的文本，称为负向前/后查找

各种前后查找操作符：

| 操作符  | 说明                     |
| ------- | ------------------------ |
| `(?=)`  | 正向前查找(肯定顺序环视) |
| `(?!)`  | 负向前查找(否定顺序环视) |
| `(?<=)` | 正向后查找(肯定逆序环视) |
| `(?<!)` | 负向后查找(否定逆序环视) |

否定的意思是如果正则表达式匹配成功，则在当前位置匹配失败。

顺序是指当前位置右侧，逆序是指当前位置的左侧。肯定是指子表达式能匹配的字符串必须出现，否定则是子表达式能匹配的字符串不能出现。

- `(?=\d{3})`右侧必须出现三个数字字符
- `(?!\d{3})`右侧不能出现三个数字字符
- `(?<=\d{3})`左侧必须出现三个数字字符
- `(?<!\d{3})`左侧必须出现三个数字字符

比如在一段有价格和数量的文本里，`I paid $30 for 100 apples`

匹配价格用`(?<=\$)\d+`，匹配数量用`\b(?<!\$)\d+\b`

准确匹配open tag：

```python
openTagRegex = r"\A<(?!/)('[^']*'|\"[^\"]*\"|[^'\">])+(?<!/)>\Z"
re.search(openTagRegex, "<input name=txt value=\">\">") != None   # True
re.search(openTagRegex, "<input name=txt value='>'>") != None   # True
re.search(openTagRegex, "<u>") != None   # True
re.search(openTagRegex, "<br/>") != None   # False
re.search(openTagRegex, "<img src=\"url\"/>") != None   # False
```

格式化数字字符串，加入逗号的位置是：右侧的数字字符串的长度是3的倍数（且只能是3的倍数，不能有多余的数字），且左侧也是数字字符。

```python
re.sub(r"(?<=\d)(?=(\d{3})+(?!\d))", r",","123456")
# 123,456
```

去掉中英文混排文本中不必要的空白字符

```python
mixedString = " 中 英文混排，some English word，有多余的空 白字符  "
negativeSpaceTrimRegex = r"(?<![a-zA-Z])\s+(?![a-zA-Z])"
print("["+re.sub(negativeSpaceTrimRegex, "", mixedString)+"]")
# [中英文混排，some English word，有多余的空白字符]
positiveSpaceTrimRegex = r"(?<=[^a-zA-Z])\s+(?=[^a-zA-Z])"
print("["+re.sub(positiveSpaceTrimRegex, "", mixedString)+"]")
# [ 中英文混排，some English word，有多余的空白字符 ]
```

肯定环视要判断成功，字符串中必须有字符由环视结构中的表达式匹配；而否定环视要判断成功，却有两种情况：字符串中出现了字符，但这些字符不能由环视结构中的表达式匹配；或者字符串中不再有任何字符，也就是说，这个位置是字符串的起始位置或者结束位置。

在电子邮件地址中，进行主机名验证。主机名以点号分隔为多个域名字段，每个域名字段可以包含大小写字母、数字字母、横线，但是横线不能出现在开头位置。每个域名字段的长度最多为63个字符，整个主机名的长度最多为255个字符。

```python
hostnameRegex = r"^(?=[-a-zA-Z0-9.]{0,255}(?![-a-zA-Z0-9.]))((?!-)[-a-zA-Z0-9]{1,63}\.)*((?!-)[-a-zA-Z0-9]){1,63}$"
re.search(hostnameRegex, "localhost") != None  # True
re.search(hostnameRegex, "example.com") != None  # True
re.search(hostnameRegex, "-example.com") != None  # False
re.search(hostnameRegex, ("e" * 64)+".com") != None  # False
re.search(hostnameRegex, "e"*256) != None  # False
```

一般来说，凡是从文本中提取“有长度特征的数据”，都需要用到环视。比如准确匹配6位数字构成的字符串，`(?<!\d)\d{6}(?!\d)`

从26个字母中减去5个辅音字母，`(?![aeiou])[a-z]`

环视结构中的括号只是结构需要，并不影响捕获分组。

环视结构中出现了捕获型括号，会影响分组

```python
print(re.search(r"^(?=(ab|cd))", "abcd")).group(0)

print(re.search(r"^(?=(ab|cd))", "abcd")).group(1)
# ab
print(re.search(r"^(?=(?:ab|cd))", "abcd")).group(1)
# 报错no such group
```

环视结构中的捕获型括号一旦匹配完成，就不能回溯。

Python规定在逆序环视中的表达式能匹配的文本长度必须是固定的。`(?<=dog)`和`(?<=(dog|cat))`都是合法的，而`(?<=dog?)`和`(?<=(dog|cats))`都不合法，因为环视中的子表达式能匹配的文本长度不确定。

可以用多选结构来改写。`((?<=dog)|(?<=dogs))`, `((?<=dog)|(?<=cats))`。

**环视的组合**

环视匹配的并不是字符，而是位置。多个环视可以组合在一起，实现同一个位置的多重判断。

环视中包含环视：`(?=[-a-zA-Z0-9.]{0,255}(?![-a-zA-Z0-9.]))`保证的是整个主机名字符串的长度在255个字符以内。

并列多个环视，并列的先后顺序无所谓：查找这样的起始位置，它之后是数字字符串，不过不能以999开头。

```python
re.search(r"^(?=\d+)(?!999)", "1234") != None  # True
re.search(r"^(?=\d+)(?!999)", "abcd") != None  # False
re.search(r"^(?=\d+)(?!999)", "9991234") != None  # False
```

将若干个环视作为多选分支排列在多选结构中。比如想找到这样的位置，它之后要么不是数字字符，要么是一个数字字符和一个非数字字符。总的环视就是`((?!\d)|(?=\d\D))`。



## 嵌入条件

回溯引用条件只在前面的子表达式搜索取得成功的情况下才允许使用一个表达式。

用来定义这种条件的语法是`(?(backreference)true-regex)`，其中`?`表明这是一个条件，括号里的backreference是一个回溯引用，true-regex是一个只在backreference存在时才会被执行的子表达式。

例子：需要把一段文本里的`<IMG>`标签全都找出来，如果某个`<IMG>`标签是一个链接（被括在`<A>`和`</A>`标签之间）的话，还要把整个链接标签匹配出来。



否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会被执行。用来定义这种条件的语法是`(?(backreference)true-regex|false-regex)`

下面的电话号码只有第1和第2个是合法的，我们想匹配它们：

123-456-7890

(123)456-7890

(123)-456-7890

(123-456-7890

1234567890

123 456 7890

正则表达式：`(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}`

`(\()?`匹配一个可选的左括号，`(?(1)\)|-)`是一个回溯引用条件，它将根据条件是否得到满足而去匹配`)`或`-`：如果(1)存在，`\)`必须被匹配；否则，`-`必须被匹配。这样一来，只有配对出现的括号才会被匹配；如果没有使用括号或括号不配对，电话号码中的区号和其余数字之间的-分隔符必须被匹配。



前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。

==例子没看懂==

## 匹配模式

常用的匹配模式：不区分大小写模式、单行模式、多行模式、注释模式。

不区分大小写模式有两种办法指定：以模式修饰符指定，或者以预定义的常量作为特殊参数传入来指定。

模式修饰符即模式名称对应的单个字符，使用时将其填入特定结构`(?modifier)`中(modifier为模式修饰符)，嵌在正则表达式的开头。比如不区分大小写的匹配模式对应的模式修饰符是`i`。

模式修饰符写在最开头表示整个正则表达式都指定此模式，如果出现在中间，则表示此模式从这里开始生效；如果出现在某个括号内，那么它的作用范围只限于括号内部。Python的情况不同，不管出现在哪个位置，都对整个正则表达式生效。

有另一类失效修饰符，用来终止某种模式的作用范围，`(?-modifier)`。不过Python不支持这种写法。

这个表达式几乎可以原封不动的用在任何语言中，只有JavaScript例外。

```python
# 以模式修饰符指定
re.search(r"(?i)the", "The") != None  # True
```

第二种方式是使用预定义的常量作为参数传入正则函数。比如Python是Re类的静态成员re.IGNORECASE

```python
re.compile(r"the", re.I).search("THE") != None  # True
# 或者re.search(r"(?i)the", "THE", re.I) != None
```



点号不能匹配换行符。单行模式下所有文本似乎只在一行里，换行符变成了普通字符，点号可以匹配。

单行模式对应的模式修饰符是s。Python中的预定义常量是re.S和re.DOTALL。

单行模式影响的是点号的匹配规则。

多行模式影响是的`^`和`$`的匹配规则。默认模式下，它们匹配的是整个字符串的起始位置和结束位置，但在多行模式下，它们也能匹配字符串内部某一行文本的起始位置和结束位置。

模式修饰符是m，预定义常量是re.M和re.MULTILINE

```python
multilineString = "1 line\nNot digit\n2 line"
lineBeginWithDigitRegex = r"(?m)^\d.*"
for line in re.findall(lineBeginWithDigitRegex, multilineString):
    print(line)
# 1 line
# 2 line
```



注释模式。许多语言支持使用`(?#comment)`的记法添加注释，comment就是注释的内容。模式修饰符是x。预定义常量是re.X和re.VERBOSE。

如果需要同时使用多种模式，只要将模式修饰符排列起来就可以了。比如`(?mx)`

或者将预定义常量用`|`组合起来。

Python的re还包含其他模式，列举2种

- re.U或re.UNICODE：此模式下，`\w`, `\d`, `\s`等字符组简记法的匹配规则会发生改变，比如`\w`能匹配Unicode中的“单词字符”，包括中文字符，`\d`也能匹配１、２之类的全角数字字符，它有对应的模式修饰符u。
- re.A或re.ASCII：Python3以上的版本中，正则表达式默认采用Unicode匹配规则，如果希望让`\d`, `\w`等字符组简记法恢复到ASCII匹配规则，可以使用此模式，它有对应的模式修饰符a。



## 常用的操作符模式总结

| 模式    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| ^       | 匹配字符串的开头，如^abc表示abc且在一个字符串的开头          |
| $       | 匹配字符串的结尾，如abc$表示abc且在一个字符串的结尾          |
| .       | 匹配任意字符，除了换行符                                     |
| [...]   | 可以理解为"或"。对单个字符给出取值范围，例如[amk]匹配'a','m'或'k' |
| [^...]  | 不在[]中的字符：\[^abc]匹配除了a,b,c之外的字符               |
| re*     | 前一个字符0次或无限次扩展，如abc* 表示 ab、abc、abcc、abccc等 |
| re+     | 前一个字符1次或无限次扩展 ，如abc+ 表示 abc、abcc、abccc等   |
| re?     | 前一个字符0次或1次扩展 ，如abc? 表示 ab、abc                 |
| re{n}   | 精确匹配前面的表达式n次，例如o{2}表示匹配"oo"                |
| re{n,}  | 匹配前面的表达式n次及以上                                    |
| re{n,m} | 匹配前面的表达式n到m次(含m)，如ab{1,2}c表示abc、abbc         |
| a\|b    | 匹配a或b，如abc\|def表示 abc、def                            |
| (re)    | 对正则表达式分组并记住匹配的文本，内部只能使用\|操作符 ，如(abc)表示abc，(abc\|def)表示abc、def |
| \w      | 匹配字母数字及下划线，等价于`[A‐Za‐z0‐9_]`                   |
| \W      | 匹配非字母数字及下划线                                       |
| \s      | 匹配任意空白字符，等价于[\t\n\r\f]                           |
| \S      | 匹配任意非空字符                                             |
| \d      | 匹配任意数字，等价于[0-9]                                    |
| \D      | 匹配任意非数字                                               |
| \A      | 匹配字符串开始                                               |
| \Z      | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
| \z      | 匹配字符串结束                                               |
| \G      | 匹配最后匹配完成的位置。                                     |
| \b      | 匹配一个单词边界，单词指的是数字、下划线或者字母。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。'\b99\b'可以匹配到'$99', '99'，而不会匹配到'299'。 |
| \B      | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |

### Python正则表达式re库的使用

#### 常用函数说明

- 调用方式：import re
- re库采用raw string类型表示正则表达式，表示为：r'text'，raw string是不包含对转义符再次转义的字符串;

**re库的主要功能函数**：

- `re.search()` 在一个字符串中**搜索匹配正则表达式的第一个位置**，返回match对象
  - re.search(pattern, string, flags=0)
  - 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式 
- `re.match()` 从一个字符串的**开始位置**起匹配正则表达式，返回match对象
  - re.match(pattern, string, flags=0)
  - 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式 
- `re.findall()` **搜索**字符串，以列表类型返回全部能匹配的子串
  - re.findall(pattern, string, flags=0)
- `re.split()` 将一个字符串按照正则表达式匹配结果进行**分割**，返回列表类型
  - re.split(pattern, string, maxsplit=0, flags=0)
  - maxsplit是分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 
- `re.finditer()` **搜索**字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象
  - re.finditer(pattern, string, flags=0)
- `re.sub()` 在一个字符串中**替换**所有匹配正则表达式的子串，返回替换后的字符串
  - re.sub(pattern, repl, string, count=0, flags=0)
  - repl : 替换的字符串，也可为一个函数。 
  - count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 
- 参数说明
  - pattern是匹配的正则表达式
  - string是要匹配的字符串
  - flags : 正则表达式使用时的控制标记：
    - re.I --> re.IGNORECASE : 忽略正则表达式的大小写，`[A‐Z]`能够匹配小写字符
    - re.M --> re.MULTILINE : 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始
    - re.S --> re.DOTALL : 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符

**re库的另一种等价用法（编译）**

- regex = re.compile(pattern, flags=0)：将正则表达式的字符串形式编译成正则表达式对象， 供 match() 和 search() 等函数使用。 

**re 库的贪婪匹配和最小匹配**

- `.*` Re库默认采用贪婪匹配，即输出匹配最长的子串
- `*?` 只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配

#### 实用小例子

**1.删除文本中的特殊符号**

```python
def filter_str(sentence):
  remove_nota = u'[’·°–!"#$%&\'()*+,-./:;<=>?@，。?★、…【】（）《》？“”‘’！[\\]^_`{|}~]+'
  sentence = re.sub(remove_nota, '', sentence)
  remove_punctuation_map = dict((ord(char), None) for char in string.punctuation)
  sentence = sentence.translate(remove_punctuation_map)
  return sentence.strip()
```

remove_nota列举了一些特殊符号，主要是中文的。接着用re.sub函数替换文本中的特殊符号为空值。

string.punctuation是英文的标点符号，remove_punctuation_map将这些标点符号转换成一个字典，key是符号，value是None。而translate()方法是根据参数给出的表转换字符串的字符，也就是说把文本中和key相同的字符替换成value。因为这里的value是None，也就是空值了。

给个例子：

```python
>>> filter_str('今天心情很好!@#$%^~*&')
'今天心情很好'
```

另外，附加福利，如果只想**去掉文本末尾的括号**要怎么做呢？非常简单：

```python
re.sub(r'([(].*?[)])$', '', name)
```

正则表达式前面的r表示原始字符串，比如r'\t'等价于'\t'。

先来看这个表达式的开头和结尾：'()$'，还记得吗？

'(re)'表示对正则表达式分组并记住匹配的文本。'$'表示匹配字符串的末尾。小括号里面有两个分隔的中括号，分别是'[(]'和'[)]'，也就是表示匹配左括号和右括号，这里换成'('和')'也是一样的。中间还有一个'.*?'，表示匹配任意字符0次或多次，但是在能使整个匹配成功的前提下使用最少的重复(非贪婪匹配)。

关于**贪婪和非贪婪**可以看看这个例子：

```python
>>> s="This is a number 234-235-22-423"
>>> r=re.match(".+(\d+-\d+-\d+-\d+)",s)
>>> r.group(1)
'4-235-22-423'
>>> r=re.match(".+?(\d+-\d+-\d+-\d+)",s)
>>> r.group(1)
'234-235-22-423'
```

正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的起始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。

解决方式：非贪婪操作符“？”，这个操作符可以用在"*","+","?"的后面，要求正则匹配的越少越好。

**去掉文本首尾的特殊符号以及指定字符**：

```python
def REstrip(text, param=' '):
    # 去掉首尾的param
    text0 = ''
    i = 0
    remove_nota = u'[’·!"#$%&\'()*+,-./:;<=>?@，。?★、…【】（）《》？“”‘’！[\\]^_`{|}~]+'
    while text0 != text or i == 0:
        i += 1
        text0 = text
        text = text.strip().strip(string.punctuation)
        text = text.strip(remove_nota)
        mo = re.compile(r'^([' + str(param) + r']*)(.*?)([' + str(param) + ']*)$')
        result = mo.search(text)
        text = result.group(2)
    return text
```

这里用了一个循环，是为了保证去掉首尾的所有特殊字符，防止遗漏。

**2.匹配文本中是否有某个特殊文本**

寻找文本中出现的所有英文字母：

```python
name = "abc 123 def 456"
re.findall(re.compile("[a-zA-Z]"), name)
# ['a', 'b', 'c', 'd', 'e', 'f']
```

找到文本中出现的第一个英文字母：

```python
re.search("[a-zA-Z]", name)
# <re.Match object; span=(0, 1), match='a'>
re.search("[a-zA-Z]", name).start()
# 0
re.search("[a-zA-Z]", name).span()
# (0, 1)
```

寻找关键词在文本中出现的所有起始位置：

```python
name = "123123"
keyword = "123"
start_list = [m.start() for m in re.finditer(keyword, name)]
start_list
# [0, 3]
```

如果只想要第一个起始位置，可以用：

```python
name.find(keyword)
# 0
```

**3.在中英文字符之间加上空格**：

```python
name = "今天真开心happy快乐"
name = re.sub('([A-Za-z]+)([\u4e00-\u9fa5]+)', r'\1 \2', name)
name = re.sub('([\u4e00-\u9fa5]+)([A-Za-z]+)', r'\1 \2', name)
name
# '今天真开心 happy 快乐'
```

两个表达式是类似地，只不过第一个表达式是在英文和中文字符之间加上空格，第二个表达式是在中文和英文字符之间加上空格。我们来看第一个表达式。第一个()是匹配1个或多个英文，第二个()是匹配1个或多个中文字符，r'\1 \2'是匹配第1个分组和第2个分组，且中间加了空格。

**4.自定义分隔符**

比如，以数字作为分隔符：

```python
name = "我有2只眼睛1个鼻子"
re.split('\d', name)
# ['我有', '只眼睛', '个鼻子']
re.split('(\d)', name)
# ['我有', '2', '只眼睛', '1', '个鼻子']
```

加上()会使得分割后的列表保留数字，不加的话就不会保留。

以数字和空格作为分隔符：

```python
name = "我有1只松鼠 2条狗  66只猫 还有鱼7 信不信"
re.split('(?<=\d)\s+|\s+(?=\d)', name)
# ['我有1只松鼠', '2条狗', '66只猫 还有鱼7', '信不信']
```

看到结果是：有空格+数字，或者数字+空格的地方都被分隔开了。且分隔后将空格去掉，数字保留。

要理解这个表达式，首先需要理解几个概念：

```python
# 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
# 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
# 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
# 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```

例如：

```python
re.sub('(?<=中国)人', 'rr', '中国人') # 匹配中国人中的人，将其替换为rr，结果为 中国rr
re.sub('(?<=中国)人', 'rr', '法国人') # 结果为 法国人，因为人前面不是中国，所以无法匹配到
```

所以`(?<=\d)\s+`是查找数字后面的空格（可以是多个），`\s+(?=\d)`是查找数字前面的空格（可以是多个）。

再看看另一个类似的语法` ?: `

```python
()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
```

举例1

```python
re.findall('industr(?:y|ies)', 'industriesy')
# 等价于re.findall('industry|industries', 'industriesy')
# ['industries']
re.findall('industr(y|ies)', 'industriesy')
# ['ies']
```

举例2：数字格式化

```python
# 数字格式化例如 1,123,000
re.sub('\B(?=(?:\d{3})+(?!\d))', ',', '1234567890')
# 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
```

## 参考资料

https://www.runoob.com/regexp/regexp-syntax.html

[《Speech and Language Processing》](https://web.stanford.edu/~jurafsky/slp3/)