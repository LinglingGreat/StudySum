正则表达式(regular expression, 简称RE)描述了一种字符串匹配的模式(pattern)，可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

通过使用正则表达式，可以： 

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。例如Linux中的`grep`命令使用正则表达式查找文件里符合表达式条件的内容。

## 基本的正则表达式

正则表达式语法由字符和操作符构成， 字符例如字母和数字表示他们自身。很多标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。

最简单的正则表达式是一串字符，例如`woodchuck`表达式可以匹配字符串"woodchuck"，`!`可以匹配感叹号"!"。正则表达式是**大小写敏感**的，所以`woodchuck`无法匹配到"Woodchuck"，可以使用`[wW]oodchuck`匹配"Woodchuck"和"woodchuck"。其中`[...]`用来表示单个字符的取值范围。

下面结合例子来熟悉一下正则表达式，用下划线来表示正则匹配到的字符串。

| 正则表达式              | 匹配                         | 举例                                     | 涉及知识点                            |
| ----------------------- | ---------------------------- | ---------------------------------------- | ------------------------------------- |
| `[wW]oodchuck`          | Woodchuck或woodchuck         | <u>Woodchuck</u>                         | 大小写敏感，`[]`表示字符取值范围      |
| `[abc]`                 | 'a', 'b'或'c'                | In uomini, in sold<u>a</u>ti             | `[]`表示字符取值范围                  |
| `[0-5]`                 | 0-5之间的数字                | plenty of 7 of <u>5</u>                  | `-`简单指定范围                       |
| `[A-Z]`                 | 一个大写字母                 | <u>M</u>r.<u>L</u>i                      | `-`简单指定范围                       |
| `[0-9]`                 | 单个数字，等价于[1234567890] | Chapter <u>1</u>                         | `-`简单指定范围                       |
| `[^A-Z]`                | 非大写字母                   | M<u>r</u>                                | `[^...]`表示非指定字符之外的字符。    |
| `[e^]`                  | 匹配'e'或者'^'               | look up <u>^</u>                         | `^`不在`[]`中第一个字符时不表示“非”   |
| `a^b`                   | 匹配"a^b"                    | look <u>a^b</u>                          | 同上                                  |
| `^the`                  | 匹配字符串的the              | <u>the</u> dog or the cat                | `^`在模式第一个字符时表示字符串的开头 |
| `the dog\.$`            | 匹配以the dog.结尾的字符串   | the cat or <u>the dog.</u>               | `$`表示字符串的结尾                   |
| `woodchucks?`           | 匹配woodchuck或woodchucks    | <u>woodchuck</u>                         | `?`表示前一个字符出现0次或1次         |
| `colou?r`               | color或colour                | <u>colour</u>                            | 同上                                  |
| `aa*`                   | a或aa或aaa...                | <u>aaaa</u>                              | `*`表示前一个字符出现0次或多次        |
| `[ab]*`                 | 0个或多个连续的a或b          | <u>aaa</u>, <u>abab</u>, <u>bbb</u>      | 同上                                  |
| `[0-9][0-9]*`或`[0-9]+` | 1个或多个连续的数字          | $<u>123</u>                              | `+`表示前一个字符出现1次或多次        |
| `beg.n`                 | beg+任意字符+n               | <u>begin</u>, <u>beg'n</u>, <u>begun</u> | `.`表示任意单个字符(除了换行符)       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |
|                         |                              |                                          |                                       |

P14

## 匹配单个字符

1.匹配纯文本，比如Ben，think等。

- 可能有多个匹配结果，比如Python中的re.find是只返回第一个匹配结果，re.findall是返回所有匹配结果。
- 字母是大小写敏感的，B只能匹配B，不能匹配b。Python库中的参数re.I可以设置是否忽略大小写。

2.匹配任意单个字符用`.`

3.匹配特殊字符。一些字符在正则表达式里有特殊的含义，比如`.`表示任意单个字符，如果想匹配`.`这个字符，就要用转移字符`\`，即`\.`就可以匹配`.`这个字符。

## 匹配一组字符

1.匹配多个字符中的某一个用`[]`，比如`[abc]`表示匹配a或b或c

2.利用字符集合区间，比如`[0-9]`表示匹配0-9里的任意数字, 其它的字符集合区间还有`[A-Z]`, `[a-z]`, `[a-f]`等

3.取非匹配`^`，也就是说，除了那个字符集合里的字符，其它字符都可以匹配。比如`[^0-9]`匹配任意不是数字的字符。

## 使用元字符

1.元字符是一些在正则表达式里有有特殊含义的字符，这些字符无法用来代表它本身。只有在元字符前面加上反斜杠`\`才能用来表示它本身。

要匹配`\`本身，也要在前面加上`\`，得到`\\`。

2.匹配空白字符

| 元字符 | 说明                              |
| ------ | --------------------------------- |
| `[\b]` | 回退(并删除)一个字符(Backspace键) |
| `\f`   | 换页符                            |
| `\n`   | 换行符                            |
| `\r`   | 回车符                            |
| `\t`   | 制表符(Tab键)                     |
| `\v`   | 垂直制表符                        |

比如`\r\n`匹配一个“回车+换行”组合，有许多操作系统（比如Windows）都把这个组合用作文本行的结束标签。Unix和Linux系统只使用一个换行符来结束一个文本行。

3.匹配特定的字符类别

| 元字符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `\d`   | 任何一个数字字符(等价于`[0-9]`)                              |
| `\D`   | 任何一个非数字字符(等价于`[^0-9]`)                           |
| `\w`   | 任何一个字符数字字符(大小写均可)或下划线字符(等价于`[a-zA-Z0-9_]`) |
| `\W`   | 任何一个非字母数字或下划线字符(等价于`[^a-zA-Z0-9_]`)        |
| `\s`   | 任何一个空白字符(等价于`[\f\n\r\t\v]`)                       |
| `\S`   | 任何一个非空白字符(等价于`[^\f\n\r\t\v]`)                    |

十六进制，比如`\x0A`对应于ASCII字符10(换行符)，其效果等价于`\n`

八进制，比如`\011`对应于ASCII字符9(制表符)，其效果等价于`\t`。

4.使用POSIX字符类

POSIX字符类是许多(但不是所有)正则表达式实现都支持的一种简写形式。

| 字符类       | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| `[:alnum:]`  | 任何一个字母或数字(等价于`[a-zA-Z0-9]`)              |
| `[:alpha:]`  | 任何一个字母(等价于`[a-zA-Z]`)                       |
| `[:blank:]`  | 空格或制表符(等价于`[\t ]`)                          |
| `[:cntrl:]`  | ASCII控制字符(ASCII 0到31，再加上ASCII 127)          |
| `[:digit:]`  | 任何一个数字(等价于`[0-9]`)                          |
| `[:graph:]`  | 和`[:print:]`一样，但不包括空格                      |
| `[:lower:]`  | 任何一个小写字母(等价于`[a-z]`)                      |
| `[:print:]`  | 任何一个可打印字符                                   |
| `[:punct:]`  | 既不属于`[:alnum:]`也不属于`[:cntrl:]`的任何一个字符 |
| `[:space:]`  | 任何一个空白字符，包括空格(等价于`[^\f\n\r\t\v ]`)   |
| `[:upper:]`  | 任何一个大写字母(等价于`[A-Z]`)                      |
| `[:xdigit:]` | 任何一个十六进制数字(等价于`[a-fA-F0-9]`)            |

注意`[]`是POSIX字符类本身的组成部分

## 常用的操作符模式总结

| 模式    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| ^       | 匹配字符串的开头，如^abc表示abc且在一个字符串的开头          |
| $       | 匹配字符串的结尾，如abc$表示abc且在一个字符串的结尾          |
| .       | 匹配任意字符，除了换行符                                     |
| [...]   | 可以理解为"或"。对单个字符给出取值范围，例如[amk]匹配'a','m'或'k' |
| [^...]  | 不在[]中的字符：\[^abc]匹配除了a,b,c之外的字符               |
| re*     | 前一个字符0次或无限次扩展，如abc* 表示 ab、abc、abcc、abccc等 |
| re+     | 前一个字符1次或无限次扩展 ，如abc+ 表示 abc、abcc、abccc等   |
| re?     | 前一个字符0次或1次扩展 ，如abc? 表示 ab、abc                 |
| re{n}   | 精确匹配前面的表达式n次，例如o{2}表示匹配"oo"                |
| re{n,}  | 匹配前面的表达式n次及以上                                    |
| re{n,m} | 匹配前面的表达式n到m次(含m)，如ab{1,2}c表示abc、abbc         |
| a\|b    | 匹配a或b，如abc\|def表示 abc、def                            |
| (re)    | 对正则表达式分组并记住匹配的文本，内部只能使用\|操作符 ，如(abc)表示abc，(abc\|def)表示abc、def |
| \w      | 匹配字母数字及下划线，等价于`[A‐Za‐z0‐9_]`                   |
| \W      | 匹配非字母数字及下划线                                       |
| \s      | 匹配任意空白字符，等价于[\t\n\r\f]                           |
| \S      | 匹配任意非空字符                                             |
| \d      | 匹配任意数字，等价于[0-9]                                    |
| \D      | 匹配任意非数字                                               |
| \A      | 匹配字符串开始                                               |
| \Z      | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
| \z      | 匹配字符串结束                                               |
| \G      | 匹配最后匹配完成的位置。                                     |
| \b      | 匹配一个单词边界，单词指的是数字、下划线或者字母。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。'\b99\b'可以匹配到'$99', '99'，而不会匹配到'299'。 |
| \B      | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |

### Python正则表达式re库的使用

#### 常用函数说明

- 调用方式：import re
- re库采用raw string类型表示正则表达式，表示为：r'text'，raw string是不包含对转义符再次转义的字符串;

**re库的主要功能函数**：

- `re.search()` 在一个字符串中**搜索匹配正则表达式的第一个位置**，返回match对象
  - re.search(pattern, string, flags=0)
  - 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式 
- `re.match()` 从一个字符串的**开始位置**起匹配正则表达式，返回match对象
  - re.match(pattern, string, flags=0)
  - 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式 
- `re.findall()` **搜索**字符串，以列表类型返回全部能匹配的子串
  - re.findall(pattern, string, flags=0)
- `re.split()` 将一个字符串按照正则表达式匹配结果进行**分割**，返回列表类型
  - re.split(pattern, string, maxsplit=0, flags=0)
  - maxsplit是分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 
- `re.finditer()` **搜索**字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象
  - re.finditer(pattern, string, flags=0)
- `re.sub()` 在一个字符串中**替换**所有匹配正则表达式的子串，返回替换后的字符串
  - re.sub(pattern, repl, string, count=0, flags=0)
  - repl : 替换的字符串，也可为一个函数。 
  - count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 
- 参数说明
  - pattern是匹配的正则表达式
  - string是要匹配的字符串
  - flags : 正则表达式使用时的控制标记：
    - re.I --> re.IGNORECASE : 忽略正则表达式的大小写，`[A‐Z]`能够匹配小写字符
    - re.M --> re.MULTILINE : 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始
    - re.S --> re.DOTALL : 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符

**re库的另一种等价用法（编译）**

- regex = re.compile(pattern, flags=0)：将正则表达式的字符串形式编译成正则表达式对象， 供 match() 和 search() 等函数使用。 

**re 库的贪婪匹配和最小匹配**

- `.*` Re库默认采用贪婪匹配，即输出匹配最长的子串
- `*?` 只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配

#### 实用小例子

**1.删除文本中的特殊符号**

```python
def filter_str(sentence):
  remove_nota = u'[’·°–!"#$%&\'()*+,-./:;<=>?@，。?★、…【】（）《》？“”‘’！[\\]^_`{|}~]+'
  sentence = re.sub(remove_nota, '', sentence)
  remove_punctuation_map = dict((ord(char), None) for char in string.punctuation)
  sentence = sentence.translate(remove_punctuation_map)
  return sentence.strip()
```

remove_nota列举了一些特殊符号，主要是中文的。接着用re.sub函数替换文本中的特殊符号为空值。

string.punctuation是英文的标点符号，remove_punctuation_map将这些标点符号转换成一个字典，key是符号，value是None。而translate()方法是根据参数给出的表转换字符串的字符，也就是说把文本中和key相同的字符替换成value。因为这里的value是None，也就是空值了。

给个例子：

```python
>>> filter_str('今天心情很好!@#$%^~*&')
'今天心情很好'
```

另外，附加福利，如果只想**去掉文本末尾的括号**要怎么做呢？非常简单：

```python
re.sub(r'([(].*?[)])$', '', name)
```

正则表达式前面的r表示原始字符串，比如r'\t'等价于'\t'。

先来看这个表达式的开头和结尾：'()$'，还记得吗？

'(re)'表示对正则表达式分组并记住匹配的文本。'$'表示匹配字符串的末尾。小括号里面有两个分隔的中括号，分别是'[(]'和'[)]'，也就是表示匹配左括号和右括号，这里换成'('和')'也是一样的。中间还有一个'.*?'，表示匹配任意字符0次或多次，但是在能使整个匹配成功的前提下使用最少的重复(非贪婪匹配)。

关于**贪婪和非贪婪**可以看看这个例子：

```python
>>> s="This is a number 234-235-22-423"
>>> r=re.match(".+(\d+-\d+-\d+-\d+)",s)
>>> r.group(1)
'4-235-22-423'
>>> r=re.match(".+?(\d+-\d+-\d+-\d+)",s)
>>> r.group(1)
'234-235-22-423'
```

正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的起始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。

解决方式：非贪婪操作符“？”，这个操作符可以用在"*","+","?"的后面，要求正则匹配的越少越好。

**去掉文本首尾的特殊符号以及指定字符**：

```python
def REstrip(text, param=' '):
    # 去掉首尾的param
    text0 = ''
    i = 0
    remove_nota = u'[’·!"#$%&\'()*+,-./:;<=>?@，。?★、…【】（）《》？“”‘’！[\\]^_`{|}~]+'
    while text0 != text or i == 0:
        i += 1
        text0 = text
        text = text.strip().strip(string.punctuation)
        text = text.strip(remove_nota)
        mo = re.compile(r'^([' + str(param) + r']*)(.*?)([' + str(param) + ']*)$')
        result = mo.search(text)
        text = result.group(2)
    return text
```

这里用了一个循环，是为了保证去掉首尾的所有特殊字符，防止遗漏。

**2.匹配文本中是否有某个特殊文本**

寻找文本中出现的所有英文字母：

```python
name = "abc 123 def 456"
re.findall(re.compile("[a-zA-Z]"), name)
# ['a', 'b', 'c', 'd', 'e', 'f']
```

找到文本中出现的第一个英文字母：

```python
re.search("[a-zA-Z]", name)
# <re.Match object; span=(0, 1), match='a'>
re.search("[a-zA-Z]", name).start()
# 0
re.search("[a-zA-Z]", name).span()
# (0, 1)
```

寻找关键词在文本中出现的所有起始位置：

```python
name = "123123"
keyword = "123"
start_list = [m.start() for m in re.finditer(keyword, name)]
start_list
# [0, 3]
```

如果只想要第一个起始位置，可以用：

```python
name.find(keyword)
# 0
```

**3.在中英文字符之间加上空格**：

```python
name = "今天真开心happy快乐"
name = re.sub('([A-Za-z]+)([\u4e00-\u9fa5]+)', r'\1 \2', name)
name = re.sub('([\u4e00-\u9fa5]+)([A-Za-z]+)', r'\1 \2', name)
name
# '今天真开心 happy 快乐'
```

两个表达式是类似地，只不过第一个表达式是在英文和中文字符之间加上空格，第二个表达式是在中文和英文字符之间加上空格。我们来看第一个表达式。第一个()是匹配1个或多个英文，第二个()是匹配1个或多个中文字符，r'\1 \2'是匹配第1个分组和第2个分组，且中间加了空格。

**4.自定义分隔符**

比如，以数字作为分隔符：

```python
name = "我有2只眼睛1个鼻子"
re.split('\d', name)
# ['我有', '只眼睛', '个鼻子']
re.split('(\d)', name)
# ['我有', '2', '只眼睛', '1', '个鼻子']
```

加上()会使得分割后的列表保留数字，不加的话就不会保留。

以数字和空格作为分隔符：

```python
name = "我有1只松鼠 2条狗  66只猫 还有鱼7 信不信"
re.split('(?<=\d)\s+|\s+(?=\d)', name)
# ['我有1只松鼠', '2条狗', '66只猫 还有鱼7', '信不信']
```

看到结果是：有空格+数字，或者数字+空格的地方都被分隔开了。且分隔后将空格去掉，数字保留。

要理解这个表达式，首先需要理解几个概念：

```python
# 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
# 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
# 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
# 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```

例如：

```python
re.sub('(?<=中国)人', 'rr', '中国人') # 匹配中国人中的人，将其替换为rr，结果为 中国rr
re.sub('(?<=中国)人', 'rr', '法国人') # 结果为 法国人，因为人前面不是中国，所以无法匹配到
```

所以`(?<=\d)\s+`是查找数字后面的空格（可以是多个），`\s+(?=\d)`是查找数字前面的空格（可以是多个）。

再看看另一个类似的语法` ?: `

```python
()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
```

举例1

```python
re.findall('industr(?:y|ies)', 'industriesy')
# 等价于re.findall('industry|industries', 'industriesy')
# ['industries']
re.findall('industr(y|ies)', 'industriesy')
# ['ies']
```

举例2：数字格式化

```python
# 数字格式化例如 1,123,000
re.sub('\B(?=(?:\d{3})+(?!\d))', ',', '1234567890')
# 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
```

## 参考资料

https://www.runoob.com/regexp/regexp-syntax.html

[《Speech and Language Processing》](https://web.stanford.edu/~jurafsky/slp3/)